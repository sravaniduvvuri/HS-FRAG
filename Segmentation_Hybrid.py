# -*- coding: utf-8 -*-
"""
/***************************************************************************
 Segmentation_Hybrid
                                 A QGIS plugin
 This plugin can be used to run segmentation lgorithms
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2021-04-17
        git sha              : $Format:%H$
        copyright            : (C) 2021 by Sravani D
        email                : sravanidvr@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction, QFileDialog    
from qgis.analysis import QgsRasterCalculatorEntry, QgsRasterCalculator 
from qgis.core import QgsRasterLayer, QgsVectorLayer, QgsVectorFileWriter, QgsWkbTypes, QgsProcessingFeedback

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .Segmentation_Hybrid_dialog import Segmentation_HybridDialog, HelpDialog
import os.path
import os
from osgeo import gdal, ogr
import processing
import gdal 
import numpy as np
import matplotlib.pyplot as plt
from sklearn.metrics import r2_score
import pandas as pd

class Segmentation_Hybrid:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'HS-FRAG_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&HS-FRAG')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('HS-FRAG', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/Segmentation_Hybrid/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'HS-FRAG'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&HS-FRAG'),
                action)
            self.iface.removeToolBarIcon(action)
    def select_Overall(self):
          filename, _filter = QFileDialog.getOpenFileName(
            self.dlg, "Select   input file ","", '*.*')            
          self.dlg.leOverall.setText(filename)
    def select_NonAgri(self):
          filename, _filter = QFileDialog.getOpenFileName(
            self.dlg, "Select   input file ","", '*.*')
          self.dlg.leNonAgri.setText(filename)
    def select__files(self):
          existingFile = self.dlg.leSobelInput.text()
          filename, _filter = QFileDialog.getOpenFileName(
            self.dlg, "Select   input file ","", '*.*')
          filename = existingFile + filename + ';'
          self.dlg.leSobelInput.setText(filename)
          self.set_coordinates(filename.split(';')[0])
    #-----------------------------
    #pyrcc5 -o resources.py resources.qrc
    def select_reference(self):
          filename, _filter = QFileDialog.getOpenFileName(self.dlg, "Select   input file ","", '*.*')
          self.dlg.referenceInputBox.setText(filename)
    def select_reference2(self):
          filename, _filter = QFileDialog.getOpenFileName(self.dlg, "Select   input file ","", '*.*')
          self.dlg.referenceInputBox2.setText(filename)
    def select_reference3(self):
          filename, _filter = QFileDialog.getOpenFileName(self.dlg, "Select   input file ","", '*.*')
          self.dlg.referenceInputBox3.setText(filename)

    def select_geo_reference(self):
          filename, _filter = QFileDialog.getOpenFileName(self.dlg, "Select   input file ","", '*.*')
          self.dlg.referenceGeoInputBox.setText(filename)
    def select_spatial_reference(self):
          filename, _filter = QFileDialog.getOpenFileName(self.dlg, "Select   input file ","", '*.*')
          self.dlg.referenceSpatialInputBox.setText(filename)

    def openHelpTab(self):
        print("Help tab clicked")
        self.sc = HelpDialog()
        self.sc.show()

    #Functions for spatial evaluation clipping raster to vector
    def ClipRasterWithPolygon(self, rasterPath, polyPath, outPath):
        processing.run('gdal:cliprasterbymasklayer',{
                       'INPUT': rasterPath,
                       'MASK': polyPath,
                       'NODATA': -1,
                       'ALPHA_BAND': False,
                       'CROP_TO_CUTLINE': True,
                       'KEEP_RESOLUTION': True,
                       'OPTIONS': "",
                       'DATA_TYPE': 0,
                       'OUTPUT': outPath,
                       })
        print("Command Run")

    def CreateClippingPolygons(self, spatialOutDir, inPath, field, bufferWidth):
        """
        Function to export individual features as separate polygons with added buffer of given bufferWidth
        """
        driverSHP = ogr.GetDriverByName("ESRI Shapefile")
        ds = driverSHP.Open(inPath)
        if ds is None:
            print("Layer not open")
        layer = ds.GetLayer()
        spatialRef = layer.GetSpatialRef()
        for feature in layer:
            
            fieldVal = feature.GetField(field)
            os.mkdir(spatialOutDir+"/ClippingFeatures/"+str(fieldVal))
            #custom buffer
            outds = driverSHP.CreateDataSource(spatialOutDir+"/ClippingFeatures/"+str(fieldVal)+"/clip_overall_buffer.shp")
            outlayer = outds.CreateLayer(str(fieldVal)+"/clip_overall_buffer.shp", srs=spatialRef, geom_type=ogr.wkbPolygon)
            outDfn = outlayer.GetLayerDefn()
            ingeom = feature.GetGeometryRef()
            #buffer takes two arguments; the buffer distance (which we defined above) and the number of line segments used to make a quarter circle (here set to 5)
            ingeom = ingeom.Buffer(bufferWidth, 5) 
            outFeat = ogr.Feature(outDfn)
            outFeat.SetGeometry(ingeom)
            outlayer.CreateFeature(outFeat)

            outdsBoundary = driverSHP.CreateDataSource(spatialOutDir+"ClippingFeatures/"+str(fieldVal)+"/clip_boundary_buffer.shp")
            outlayerBoundary = outdsBoundary.CreateLayer(str(fieldVal)+"/clip_boundary_buffer.shp", srs=spatialRef, geom_type=ogr.wkbPolygon)
            outDfnBoundary = outlayerBoundary.GetLayerDefn()
            ingeomBoundary = feature.GetGeometryRef()
            ingeomBoundary = ingeomBoundary.Boundary()
            #buffer takes two arguments; the buffer distance (which we defined above) and the number of line segments used to make a quarter circle (here set to 5)
            ingeomBoundary = ingeomBoundary.Buffer(bufferWidth, 5)
            outFeatBoundary = ogr.Feature(outDfnBoundary)
            outFeatBoundary.SetGeometry(ingeomBoundary)
            outlayerBoundary.CreateFeature(outFeatBoundary)

            #2 meter buffer-----------------------------------------
            # outds = driverSHP.CreateDataSource(spatialOutDir+"/ClippingFeatures/"+str(fieldVal)+"/clip_2m.shp")
            # outlayer = outds.CreateLayer(str(fieldVal)+"/clip_2m.shp", srs=spatialRef, geom_type=ogr.wkbPolygon)
            # outDfn = outlayer.GetLayerDefn()
            # ingeom = feature.GetGeometryRef()
            # ingeom = ingeom.Buffer(2.0, 5)
            # outFeat = ogr.Feature(outDfn)
            # outFeat.SetGeometry(ingeom)
            # outlayer.CreateFeature(outFeat)

            # outdsBoundary = driverSHP.CreateDataSource(spatialOutDir+"ClippingFeatures/"+str(fieldVal)+"/clip_boundary_2m.shp")
            # outlayerBoundary = outdsBoundary.CreateLayer(str(fieldVal)+"/clip_boundary_2m.shp", srs=spatialRef, geom_type=ogr.wkbPolygon)
            # outDfnBoundary = outlayerBoundary.GetLayerDefn()
            # ingeomBoundary = feature.GetGeometryRef()
            # ingeomBoundary = ingeomBoundary.Boundary()
            # ingeomBoundary = ingeomBoundary.Buffer(2.0, 5)
            # outFeatBoundary = ogr.Feature(outDfnBoundary)
            # outFeatBoundary.SetGeometry(ingeomBoundary)
            # outlayerBoundary.CreateFeature(outFeatBoundary)

    def ClipRasters(self, spatialOutDir, inPath, field, outDir, bufferWidth):
        """
        Function to clip all the features exported as vectors to the borders.sdat file for pixel analysis
        """
        driverSHP = ogr.GetDriverByName("ESRI Shapefile")
        ds = driverSHP.Open(inPath)
        if ds is None:
            print("Layer not open -")
        layer = ds.GetLayer()

        inRasterpath = outDir+"borders.sdat"
        #custom buffer
        spatialRef_ids = []
        region_total_pixels = []
        region_nodata_pixels = []
        region_diff_pixels = []
        boundary_total_pixels = []
        boundary_nodata_pixels = []
        boundary_diff_pixels = []
        accuracy = []

        #2 meter buffer -----------
        # region_total_pixels_2m = []
        # region_nodata_pixels_2m = []
        # region_diff_pixels_2m = []
        # boundary_total_pixels_2m = []
        # boundary_nodata_pixels_2m = []
        # boundary_diff_pixels_2m = []
        # accuracy_2m = []

        for feature in layer:
            fieldVal = feature.GetField(field)
            spatialRef_ids.append(fieldVal)
            print("fieldVal - "+str(fieldVal))

            self.ClipRasterWithPolygon(inRasterpath, spatialOutDir+"ClippingFeatures/"+str(fieldVal)+"/clip_overall_buffer.shp", spatialOutDir+"ClippingFeatures/"+str(fieldVal)+"/clip_raster_buffer.tif")
            self.ClipRasterWithPolygon(inRasterpath, spatialOutDir+"ClippingFeatures/"+str(fieldVal)+"/clip_boundary_buffer.shp", spatialOutDir+"ClippingFeatures/"+str(fieldVal)+"/clip_raster_boundary_buffer.tif")

            # self.ClipRasterWithPolygon(inRasterpath, spatialOutDir+"ClippingFeatures/"+str(fieldVal)+"/clip_2m.shp", spatialOutDir+"ClippingFeatures/"+str(fieldVal)+"/clip_raster_2m.tif")
            # self.ClipRasterWithPolygon(inRasterpath, spatialOutDir+"ClippingFeatures/"+str(fieldVal)+"/clip_boundary_2m.shp", spatialOutDir+"ClippingFeatures/"+str(fieldVal)+"/clip_raster_boundary_2m.tif")
            
            # custom buffer
            raster_data_overall = processing.run('qgis:rasterlayeruniquevaluesreport',{
                'BAND' : 1,
                'INPUT' : spatialOutDir+"ClippingFeatures/"+str(fieldVal)+"/clip_raster_buffer.tif",
                'OUTPUT_HTML_FILE' : spatialOutDir+"ClippingFeatures/"+str(fieldVal)+"/raster_data_overall_buffer.html",
               })
            raster_data_boundary = processing.run('qgis:rasterlayeruniquevaluesreport',{
                'BAND' : 1,
                'INPUT' : spatialOutDir+"ClippingFeatures/"+str(fieldVal)+"/clip_raster_boundary_buffer.tif",
                'OUTPUT_HTML_FILE' : spatialOutDir+"ClippingFeatures/"+str(fieldVal)+"/raster_data_boundary_buffer.html",
               })

            region_total_pixels.append( raster_data_overall['TOTAL_PIXEL_COUNT'] )
            region_nodata_pixels.append( raster_data_overall['NODATA_PIXEL_COUNT'] )
            reg_diff = raster_data_overall['TOTAL_PIXEL_COUNT'] - raster_data_overall['NODATA_PIXEL_COUNT']
            region_diff_pixels.append( reg_diff )

            boundary_total_pixels.append( raster_data_boundary['TOTAL_PIXEL_COUNT'] )
            boundary_nodata_pixels.append( raster_data_boundary['NODATA_PIXEL_COUNT'] )
            bound_diff = raster_data_boundary['TOTAL_PIXEL_COUNT'] - raster_data_boundary['NODATA_PIXEL_COUNT']
            boundary_diff_pixels.append( bound_diff )

            accuracy.append((bound_diff/ reg_diff)*100)

            # 2 meter buffer -------------------------------
            # raster_data_region_2m = processing.run('qgis:rasterlayeruniquevaluesreport',{
            #     'BAND' : 1,
            #     'INPUT' : spatialOutDir+"ClippingFeatures/"+str(fieldVal)+"/clip_raster_2m.tif",
            #     'OUTPUT_HTML_FILE' : spatialOutDir+"ClippingFeatures/"+str(fieldVal)+"/raster_data_2m.html",
            #    })
            # raster_data_boundary_2m = processing.run('qgis:rasterlayeruniquevaluesreport',{
            #     'BAND' : 1,
            #     'INPUT' : spatialOutDir+"ClippingFeatures/"+str(fieldVal)+"/clip_raster_boundary_2m.tif",
            #     'OUTPUT_HTML_FILE' : spatialOutDir+"ClippingFeatures/"+str(fieldVal)+"/raster_data_boundary_2m.html",
            #    })

            # region_total_pixels_2m.append( raster_data_region_2m['TOTAL_PIXEL_COUNT'] )
            # region_nodata_pixels_2m.append( raster_data_region_2m['NODATA_PIXEL_COUNT'] )
            # reg_diff_2m = raster_data_region_2m['TOTAL_PIXEL_COUNT'] - raster_data_region_2m['NODATA_PIXEL_COUNT']
            # region_diff_pixels_2m.append( reg_diff_2m )

            # boundary_total_pixels_2m.append( raster_data_boundary_2m['TOTAL_PIXEL_COUNT'] )
            # boundary_nodata_pixels_2m.append( raster_data_boundary_2m['NODATA_PIXEL_COUNT'] )
            # bound_diff_2m = raster_data_boundary_2m['TOTAL_PIXEL_COUNT'] - raster_data_boundary_2m['NODATA_PIXEL_COUNT']
            # boundary_diff_pixels_2m.append( bound_diff_2m )

            # accuracy_2m.append((bound_diff_2m/ reg_diff_2m)*100)

        spa_columns = ["S.no", "ReferenceID", "RegionTotalPixels", "RegionNodataPixels", "RegionDiffPixels", "BoundaryTotalPixels", "BoundaryNodataPixels", "BoundaryDiffPixels", "Accuracy", "BufferWidth"]
        spa_results = [[i for i in range(len(spatialRef_ids))], spatialRef_ids, region_total_pixels, region_nodata_pixels, region_diff_pixels, boundary_total_pixels, boundary_nodata_pixels, boundary_diff_pixels, accuracy, [bufferWidth for i in range(len(spatialRef_ids))] ]
        df = pd.DataFrame(spa_results).T
        df.to_excel(excel_writer = outDir+"evaluation/spatial_evaluation.xlsx", index=False, header=spa_columns)
        print("xlsx generated for Spatial evaluation.")

    def count_clipped_features(self, referenceLayer, inputLayer):
        """
        Counts no of polygons overlapped with the features in reference layer
        """
        referenceFeatures = [ feat for feat in referenceLayer.getFeatures() ]
        segmentFeatures = [ feat for feat in inputLayer.getFeatures() ]
        overlappedFeatures = []

        for i, feat1 in enumerate(referenceFeatures):
            overlapped = []

            for j, feat2 in enumerate(segmentFeatures):

                if feat1.geometry().intersects(feat2.geometry()):
                    #area = feat1.geometry().intersection(feat2.geometry()).area()
                    overlapped.append( feat2.attribute('cat') )

            overlappedFeatures += overlapped

        overlappedFeatures = list(set(overlappedFeatures))

        return len(overlappedFeatures)

    #-----------------------------
    def set_coordinates(self, file):
          lyr = QgsRasterLayer(file)
          self.dlg.leMinX.setText(str(lyr.extent().xMinimum()))
          self.dlg.leMinY.setText(str(lyr.extent().yMinimum()))
          self.dlg.leMaxX.setText(str(lyr.extent().xMaximum()))
          self.dlg.leMaxY.setText(str(lyr.extent().yMaximum()))
          
    def crop_image(self, fp, data_dir, cordinates):
        out_tif = os.path.join(data_dir, "croppedImage.tif") 
        extent = str(cordinates[0]) + ',' + str(cordinates[2]) + ',' + str(cordinates[1]) + ',' + str(cordinates[3]) + '[EPSG:4326]'
        processing.run("gdal:cliprasterbyextent", { 'DATA_TYPE' : 0, 'EXTRA' : '', 'INPUT' : fp, 'NODATA' : None, 'OPTIONS' : '', 'OUTPUT' : out_tif, 'PROJWIN' : extent })
        
             
        return out_tif
    def select_output_folder(self):
      
          flags = QFileDialog.ShowDirsOnly
          dirpath = str(QFileDialog.getExistingDirectory(self.dlg, 'Choose a output folder', '', flags))
          self.dlg.leSobelOutput.setText(dirpath)
          self.dlg.leSobelOutput.setText(dirpath)

    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = Segmentation_HybridDialog()
            
            self.dlg.pbSobelInput.clicked.connect(self.select__files)   
            self.dlg.pbSobelOutPut.clicked.connect(self.select_output_folder)
            self.dlg.pbOverall.clicked.connect(self.select_Overall)
            self.dlg.pbNonAgri.clicked.connect(self.select_NonAgri)
            self.dlg.referenceSelectButton.clicked.connect(self.select_reference)
            self.dlg.referenceSelectButton2.clicked.connect(self.select_reference2)
            self.dlg.referenceSelectButton3.clicked.connect(self.select_reference3)

            self.dlg.referenceGeoSelectButton.clicked.connect(self.select_geo_reference)
            self.dlg.referenceSpatialSelectButton.clicked.connect(self.select_spatial_reference)

            self.dlg.helpButton.clicked.connect(self.openHelpTab)
        # show the dialog
        self.dlg.show()
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            minx = float(self.dlg.leMinX.text())
            miny = float(self.dlg.leMinY.text())
            maxx = float(self.dlg.leMaxX.text())
            maxy = float(self.dlg.leMaxY.text())
            print('Segmentation in progress... Please wait')
            inputFiles = self.dlg.leSobelInput.text().split(';')[:-1]
            #---------------------
            referenceVector = self.dlg.referenceInputBox.text()
            referenceVector2 = self.dlg.referenceInputBox2.text()
            referenceVector3 = self.dlg.referenceInputBox3.text()

            referenceGeoVector = self.dlg.referenceGeoInputBox.text()
            referenceSpatialVector = self.dlg.referenceSpatialInputBox.text()
            bufferWidth = float(self.dlg.bufferWidth.text())
            #----------------------
            threshold = float(self.dlg.leThreshold.text())
            outputDirectoryRoot = self.dlg.leSobelOutput.text()
            outputDirectory = outputDirectoryRoot + '/Threshold_' + self.dlg.leThreshold.text()
            try:  
                os.mkdir(outputDirectory)  
            except OSError as error:  
                print('Folder already exists. Overwriting the content.')
            entries = []
            layers = []
            expression = ''
            count = 1;
            height = None 
            width = None
            extent = None
            lyr = None
            
            overall_region = self.dlg.leOverall.text()
            non_agri_regions = self.dlg.leNonAgri.text()
            if (non_agri_regions.strip() != ""):
                processing.run('native:difference',{ 'INPUT' : overall_region, 'OUTPUT' : outputDirectory + '\difference.shp', 'OVERLAY' : non_agri_regions })    

            for uncroppedInputFile in inputFiles:
                inputExtension = uncroppedInputFile.split('.')[1]
                inputFile = self.crop_image(uncroppedInputFile, outputDirectory, [minx,miny,maxx,maxy])
                maskedInputFile = outputDirectory + '/masked' + str(count) + '.' + inputExtension
                if (non_agri_regions.strip() != ""):
                    processing.run('gdal:cliprasterbymasklayer', { 'ALPHA_BAND' : False, 'CROP_TO_CUTLINE' : True, 'DATA_TYPE' : 0, 'EXTRA' : '', 'INPUT' : inputFile, 'KEEP_RESOLUTION' : False, 'MASK' : outputDirectory + '\difference.shp', 'MULTITHREADING' : False, 'NODATA' : None, 'OPTIONS' : '', 'OUTPUT' : maskedInputFile, 'SET_RESOLUTION' : False, 'SOURCE_CRS' : None, 'TARGET_CRS' : None, 'X_RESOLUTION' : None, 'Y_RESOLUTION' : None }) 
                else:
                    processing.run('gdal:cliprasterbymasklayer', { 'ALPHA_BAND' : False, 'CROP_TO_CUTLINE' : True, 'DATA_TYPE' : 0, 'EXTRA' : '', 'INPUT' : inputFile, 'KEEP_RESOLUTION' : False, 'MASK' : overall_region , 'MULTITHREADING' : False, 'NODATA' : None, 'OPTIONS' : '', 'OUTPUT' : maskedInputFile, 'SET_RESOLUTION' : False, 'SOURCE_CRS' : None, 'TARGET_CRS' : None, 'X_RESOLUTION' : None, 'Y_RESOLUTION' : None }) 
                
                outputFile = outputDirectory + '/output' + str(count) + '.' + inputExtension                    
                print(outputFile)
                
                processing.run("gdal:slope", { 'AS_PERCENT' : False, 'BAND' : 1, 'COMPUTE_EDGES' : True, 'EXTRA' : '', 'INPUT' : maskedInputFile, 'OPTIONS' : '', 'OUTPUT' : outputFile, 'SCALE' : 1, 'ZEVENBERGEN' : False })
                ras = QgsRasterCalculatorEntry()
                exp = 'ras' + str(count) + '@1'
                ras.ref = exp
                ras.raster = QgsRasterLayer(outputFile)
                ras.bandNumber = 1
                entries.append(ras)
                expression = expression + exp
                layers.append(QgsRasterLayer(outputFile))
                
                ras = QgsRasterCalculatorEntry()
                exp = 'ras' + str(count) + '@1'
                ras.ref = exp
                ras.raster = layers[count - 1]
                ras.bandNumber = 1
                entries.append(ras)
                if count < len(inputFiles):
                    expression = expression + ' + '
                if count == 1:
                    lyr = QgsRasterLayer(outputFile)
                    extent = lyr.extent()
                    height = lyr.height()
                    width = lyr.width()
                    
                count = count + 1
            
            expression = '(' + expression + ') / ' + str(len(inputFiles))
            calc = QgsRasterCalculator(expression, outputDirectory + '/average.tif', 'GTiff', extent, width, height, entries )                
            calc.processCalculation()                
            
            processing.run("saga:watershedsegmentation", { 'BBORDERS' : True, 'BORDERS' : outputDirectory + '/borders.sdat', 'DOWN' : 0, 'EDGE' : True, 'GRID' : outputDirectory + '/average.tif', 'JOIN' : 1, 'OUTPUT' : 0, 'SEEDS' : outputDirectory + '/seeds.shp', 'SEGMENTS' : outputDirectory + '/segment.sdat', 'THRESHOLD' : threshold })
            
            processing.run('grass7:r.to.vect',{'input': outputDirectory + '/segment.sdat', 'type': 2, 'output':outputDirectory + '/segment_vector.shp'})
            
            print("-----------------------------------------------------------------------")
            print("Evaluation Started....")
            try:  
                os.mkdir(outputDirectory + "/evaluation")  
            except OSError as error:  
                print('Folder already exists. Overwriting the content.')


            segmentLayer = QgsVectorLayer(outputDirectory+'/segment_vector.shp', 'display name', 'ogr')
            print("referenceVector"+referenceVector)
            referenceLayer = QgsVectorLayer(referenceVector,'reference','ogr')
            referenceFeatureCount = referenceLayer.featureCount()
            segmentFeatureCount = self.count_clipped_features(referenceLayer, segmentLayer)


            print("segment Feature Count:"+str(segmentFeatureCount))
            print("reference feature count:"+str(referenceFeatureCount))
            gen = segmentFeatureCount/referenceFeatureCount
            print("Generalization: ", gen)
            gen_bool = ""
            if(gen>1):
                print("OverSegmentation")
                gen_bool = "Oversegmentation"
            if(gen<1):
                print("UnderSegmentation")
                gen_bool = "UnderSegmentation"
            print("Generalization Evaluation Ended...")
            print("Writing results to text document")

            gen_file = open(outputDirectory+"/evaluation/generalization_results.txt", "w+")
            gen_results = [ "Generalization Results 1 ------- \n", "Reference feature count: "+str(referenceFeatureCount) + "\n", "Segmented feature count: "+str(segmentFeatureCount)+"\n", "Generalization: "+str(gen)+"\n", gen_bool, "\n\n"]
            gen_file.writelines(gen_results)

            #Extra references
            if(referenceVector2.strip() != ""):
                referenceLayer2 = QgsVectorLayer(referenceVector2,'reference','ogr')
                referenceFeatureCount2 = referenceLayer2.featureCount()
                segmentFeatureCount2 = self.count_clipped_features(referenceLayer2, segmentLayer)

                gen2 = segmentFeatureCount2/referenceFeatureCount2
                gen_bool2 = ""
                if(gen2>1):
                    gen_bool2 = "Oversegmentation"
                if(gen2<1):
                    gen_bool2 = "UnderSegmentation"

                gen_results2 = [ "Generalization Results 2 ------- \n", "Reference feature count: "+str(referenceFeatureCount2) + "\n", "Segmented feature count: "+str(segmentFeatureCount2)+"\n", "Generalization: "+str(gen2)+"\n", gen_bool2,  "\n\n"]
                gen_file.writelines(gen_results2)

            if(referenceVector3.strip() != ""):
                referenceLayer3 = QgsVectorLayer(referenceVector3,'reference','ogr')
                referenceFeatureCount3 = referenceLayer3.featureCount()
                segmentFeatureCount3 = self.count_clipped_features(referenceLayer3, segmentLayer)

                gen3 = segmentFeatureCount3/referenceFeatureCount3
                gen_bool3 = ""
                if(gen3>1):
                    gen_bool3 = "Oversegmentation"
                if(gen2<1):
                    gen_bool3 = "UnderSegmentation"

                gen_results3 = [ "Generalization Results 3 ------- \n", "Reference feature count: "+str(referenceFeatureCount3) + "\n", "Segmented feature count: "+str(segmentFeatureCount3)+"\n", "Generalization: "+str(gen3)+"\n", gen_bool3,  "\n\n"]
                gen_file.writelines(gen_results3)

            gen_file.close()

             


            referenceGeoLayer = QgsVectorLayer(referenceGeoVector, 'geo reference', 'ogr')
            referenceGeoFeatureCount = referenceGeoLayer.featureCount()

            segmentFeatures = [ feature for feature in segmentLayer.getFeatures() ]

            referenceGeoFeatures = [ feature for feature in referenceGeoLayer.getFeatures() ]

            mappedFeatures = []
            print("\n\nGeometric Evalution--------------------\n\n")
            print("RefId\t RefArea\t SegId\t SegArea")
            for i, feat1 in enumerate(referenceGeoFeatures):
                refId = feat1.attribute('CATEGORY')
                overlapped = []

                for j, feat2 in enumerate(segmentFeatures):

                    if feat1.geometry().intersects(feat2.geometry()):
                        area = feat1.geometry().intersection(feat2.geometry()).area()
                        overlapped.append( [area, feat2.attribute('cat'), feat2] )

                if(overlapped):
                    maxOverlapped = max(overlapped)
                    #idMap = [ refId, maxOverlapped[1] ]
                    featureMap = [ feat1, maxOverlapped[2] ]
                    mappedFeatures.append( featureMap )
                    print(refId,"\t", "%.2f" % feat1.geometry().area(),"\t", maxOverlapped[1] ,"\t", "%.2f" % maxOverlapped[2].geometry().area() )

                else:
                    print(refId,"\t", "%.2f" % feat1.geometry().area(),"\t", " ----\t ----")


            plt.figure(figsize=[15, 10])
            # Data to be plotted for Area comparision
            referenceAreas = [ featPair[0].geometry().area() for featPair in mappedFeatures ]
            segmentedAreas = [ featPair[1].geometry().area() for featPair in mappedFeatures ]
            # Using numpy to group 2 different data with bars
            X = np.arange(referenceGeoFeatureCount)
            # Passing the parameters to the bar function, this is the main function which creates the bar plot
            # Using X now to align the bars side by side
            plt.bar(X, referenceAreas, color = '#fb7c0c', width = 0.35)
            plt.bar(X + 0.35, segmentedAreas, color = '#1c74b3', width = 0.35)
            # plt.bar(X + 0.5, activeCases, color = 'b', width = 0.25)

            # Creating the legend of the bars in the plot
            plt.legend(['Reference', 'Segmented'])
            # Overiding the x axis with the country names
            plt.xticks([i + 0.35 for i in range(referenceGeoFeatureCount)], [str(featPair[0].attribute('CATEGORY')) +" - "+str(featPair[1].attribute('cat')) for featPair in mappedFeatures ] )
            # Giving the tilte for the plot
            plt.title("Geometric Evaluation - Area comparision")
            # Namimg the x and y axis
            plt.xlabel('\nSegments (RefID - SegID)')
            plt.ylabel('Area')
            plt.savefig(outputDirectory + '/evaluation/area_comparision.png')
            # Displaying the bar plot
            plt.close()

            plt.figure(figsize=[15, 10])
            # Data to be plotted for Perimeter comparision 
            referencePerimeters = [ featPair[0].geometry().length() for featPair in mappedFeatures ]
            segmentedPerimeters = [ featPair[1].geometry().length() for featPair in mappedFeatures ]
            # Using numpy to group 2 different data with bars
            X = np.arange(referenceGeoFeatureCount)
            # Passing the parameters to the bar function, this is the main function which creates the bar plot
            # Using X now to align the bars side by side
            plt.bar(X, referencePerimeters, color = '#fb7c0c', width = 0.35)
            plt.bar(X + 0.35, segmentedPerimeters, color = '#1c74b3', width = 0.35)
            # plt.bar(X + 0.5, activeCases, color = 'b', width = 0.25)

            # Creating the legend of the bars in the plot
            plt.legend(['Reference', 'Segmented'])
            # Overiding the x axis with the country names
            plt.xticks([i + 0.35 for i in range(referenceGeoFeatureCount)], [str(featPair[0].attribute('CATEGORY'))+" - "+str(featPair[1].attribute('cat')) for featPair in mappedFeatures ] )
            # Giving the tilte for the plot
            plt.title("Geometric Evaluation - Perimeter comparision")
            # Namimg the x and y axis
            plt.xlabel('\nSegments (RefID - SegID)')
            plt.ylabel('Perimeter')
            plt.savefig(outputDirectory + '/evaluation/perimeter_comparision.png')
            # Displaying the bar plot
            # plt.show()
            plt.close()

            print("R-square graph ---------------")
            #perimeter-r2-plot
            xPerim = np.array(referencePerimeters)
            yPerim = np.array(segmentedPerimeters)
            nPerim = np.size(xPerim)
            nPerim=np.size(xPerim)
            meanXPerim = np.mean(xPerim)
            meanYPerim = np.mean(yPerim)
            PerimSD_xy = np.sum(yPerim*xPerim) - nPerim*meanYPerim*meanXPerim
            PerimSD_xx = np.sum(xPerim*xPerim) - nPerim*meanXPerim*meanXPerim
            PerimB1 = PerimSD_xy / PerimSD_xx
            PerimB0 = meanYPerim - PerimB1*meanXPerim
            num=(nPerim*np.sum(yPerim*xPerim)-(np.sum(yPerim)*np.sum(xPerim)))**2
            denom = ((nPerim*np.sum(xPerim*xPerim)-np.sum(xPerim)**2)*(nPerim*np.sum(yPerim*yPerim)-np.sum(yPerim)**2))
            R = num/denom

            plt.figure(figsize=[15, 10])
            plt.title("Perimeter")
            Perim_r2 = R
            #Perim_r2 = r2_score(xPerim, yPerim)
            #SSR=0
            #SST=0
            #for i in range(nPerim):
                #SSR=SSR+(xPerim[i]-yPerim[i])**2
                #SST=SST+(xPerim[i]-menaXpeim)**2
            #Perim_r2=1-(SSR/SS2)

            Perim_label = "R^2 value = "+str(round(Perim_r2, 5))
            plt.text( np.max(xPerim)-5, np.max(yPerim)+10,  Perim_label )
            plt.scatter(xPerim, yPerim)
            Perim_y2 = PerimB0 + PerimB1 * xPerim
            plt.plot(xPerim, Perim_y2, color="g")
            plt.xlabel("Reference")
            plt.ylabel("Segmented")
            plt.savefig(outputDirectory + '/evaluation/r2_perimeter.png')
            plt.close()

            #area-r2-plot
            xArea = np.array(referenceAreas)
            yArea = np.array(segmentedAreas)
            nArea = np.size(xArea)
            meanXArea = np.mean(xArea)
            meanYArea = np.mean(yArea)
            areaSD_xy = np.sum(yArea*xArea) - nArea*meanYArea*meanXArea
            areaSD_xx = np.sum(xArea*xArea) - nArea*meanXArea*meanXArea
            areaB1 = areaSD_xy / areaSD_xx
            areaB0 = meanYArea - areaB1*meanXArea
            num=(nArea*np.sum(yArea*xArea)-(np.sum(yArea)*np.sum(xArea)))**2
            denom = ((nArea*np.sum(xArea*xArea)-np.sum(xArea)**2)*(nArea*np.sum(yArea*yArea)-np.sum(yArea)**2))
            R = num/denom
            plt.figure(figsize=[15, 10])
            plt.title("Area")

            area_r2 = R
            area_label = "R^2 value = "+str(round(area_r2, 5))
            plt.text( np.max(xArea)-5, np.max(yArea)+10,  area_label )
            plt.scatter(xArea, yArea)
            area_y2 = areaB0 + areaB1 * xArea
            plt.plot(xArea, area_y2, color="g")
            plt.xlabel("Reference")
            plt.ylabel("Segmented")
            plt.savefig(outputDirectory + '/evaluation/r2_area.png')
            plt.close()

            print("Geometric Evaluation graphs generated to output folder")

            print("Generating xlsx for Geometric evaluation ----------")
            geo_columns = ["S.no", "ReferenceID", "SegmentedId", "ReferenceArea", "SegmentedArea", "ReferencePerimeter", "SegmentedPerimeter"]
            geo_ref_ids = [str(featPair[0].attribute('CATEGORY')) for featPair in mappedFeatures ]
            geo_seg_ids = [str(featPair[1].attribute('cat')) for featPair in mappedFeatures]

            geo_results = [[i for i in range(referenceGeoFeatureCount)], geo_ref_ids, geo_seg_ids, referenceAreas, segmentedAreas, referencePerimeters, referencePerimeters]
            df = pd.DataFrame(geo_results).T
            df.to_excel(excel_writer = outputDirectory+"/evaluation/geometric_evaluation.xlsx", index=False, header=geo_columns)
            print("xlsx generated for Geometric evaluation.")

            #Spatial Correctness evolution
            print("Spatial Correctness evaluation started -----------")
            referenceSpatialLayer = QgsVectorLayer(referenceSpatialVector, 'spatial reference', 'ogr')
            referenceSpatialFeatureCount = referenceSpatialLayer.featureCount()
            spatialOutDir = outputDirectory + "/evaluation/"
            os.mkdir(spatialOutDir + 'ClippingFeatures/')

            self.CreateClippingPolygons(spatialOutDir, referenceSpatialVector, "CATEGORY", bufferWidth)
            self.ClipRasters(spatialOutDir, referenceSpatialVector, "CATEGORY", outputDirectory+"/", bufferWidth)
            print("Spatial Correctness evaluation completed ------------")

            # input_raster = r""+outputDirectory+"/borders.sdat"
            # output_raster = r""+outputDirectory+"/clipped.tif"
            # input_vector = r""+referenceSpatialVector
            # result = self.clip_raster_by_vector(input_raster, input_vector, output_raster, True)
            # print('result =', result)
            # outFile = outputDirectory + '/Evaluation/bufferAdded.shp'
            # writer = QgsVectorFileWriter(outFile, 'UTF-8', fields, QgsWkbTypes.Polygon, referenceSpatialLayer.sourceCrs(), 'ESRI Shapefile')

            # for i, feat in enumerate(referenceSpatialFeatures):
            #   geom = feat.geometry()
            #   buffer = geom.buffer(6, 6) #buffer(bufDistance, no. of lines for quarter cricle)
            #   feat.setGeometry(buffer)
          #     vl = QgsVectorLayer("Point", "temporary_points", "memory")
          #     pr = vl.dataProvider()
          #     # Enter editing mode
          #     vl.startEditing()
          #     pr.addFeatures( [ feat ] )
          #     vl.commitChanges()

          #     processing.run('gdal:cliprasterbymasklayer',{
                   # 'INPUT': outputDirectory+'/borders.sdat',
                   # 'MASK': vl,
                   # 'NODATA': -1,
                   # 'ALPHA_BAND': False,
                   # 'CROP_TO_CUTLINE': True,
                   # 'KEEP_RESOLUTION': True,
                   # 'OPTIONS': "",
                   # 'DATA_TYPE': 0,
                   # 'OUTPUT': outputDirectory+'/clipped'+str(i)+".tif"
                   # })

                # print("clipped raster " + i)
                # writer.addFeature(feat)
            

            print("-----------------------------------------------------------------------")
            print('Segmentation completed... Please check the output folder')

        pass


